package require crypto

oo::class create prng::_baseseq {
	variable {*}{
		stack
	}

	constructor {} { #<<<
		if {[self next] ne ""} next

		namespace path [concat [namespace path] {
			::tcl::mathop
			::tcl::mathfunc
		}]

		set stack		{}
	}

	#>>>
	method random_uint32 {} { # [0 - 4294967295] <<<
		binary scan [my random_bytes 4] iu i
		set i
	}

	#>>>
	method random_uint64 {} { # [0 - 18446744073709551615] <<<
		binary scan [my random_bytes 8] Wu i
		set i
	}

	#>>>
	method random_number_norm {} { # [0.0 - 1.0] <<<
		# 53 bit precision
		expr {([my random_uint64] >> 11) / 9007199254740991.0}
	}

	#>>>
	method random_number_norm_halfopen {} { # [0.0 - 1.0) <<<
		expr {([my random_uint64] >> 11) / 9007199254740992.0}
	}

	#>>>
	method random_number_exponential {max} { #<<<
		expr {-log([my random_number_norm]) / 22.0 * $max}
	}

	#>>>
	method random_int {inc_bot inc_top} { #<<<
		if {$inc_top < $inc_bot} {
			set tmp		$inc_top
			set inc_top	$inc_bot
			set inc_bot	$tmp
		}
		#set size	[- $inc_top $inc_bot -1]
		#expr {
		#	$inc_bot + int([my random_number_norm] * $size)
		#}

		set extra	32
		set range	[- $inc_top $inc_bot]
		set bytes	[expr {int(ceil(([crypto::rsa::bitlength $range]+$extra) / 8.0))}]
		set base	[crypto::rsa::OS2IP [my random_bytes $bytes]]
		expr {($base % ($range+1)) + $inc_bot}
	}

	#>>>
	method random_sort {list} { #<<<
		set out	{}

		while {[llength $list] > 0} {
			set idx	[my random_int 0 [- [llength $list] 1]]
			lappend out	[lindex $list $idx]
			set list	[lreplace $list $idx $idx]
		}

		set out
	}

	#>>>
	method random_pick {list {count 1}} { #<<<
		set out	{}

		for {set i 0} {$i < $count} {incr i} {
			set idx	[my random_int 0 [- [llength $list] 1]]
			lappend out	[lindex $list $idx]
			set list	[lreplace $list $idx $idx]
		}

		set out
	}

	#>>>
	method random_normal {mean stdev} { #<<<
		# Based on tcllib's math::statistics::random-normal
		my variable twopi
		if {![info exists twopi]} {set twopi [expr {2.0 * acos(-1.0)}]}

		if {$stdev <= 0.0} {
			error "stdev must be positive"
		}

        set angle	[expr {$twopi * [my random_number_norm]}]
        set rad		[expr {sqrt(-2.0 * log([my random_number_norm]))}]
        set xrand	[expr {$rad * cos($angle)}]

        expr {$mean + $stdev * $xrand}
	}

	#>>>
	method random_exponential mean { #<<<
		expr {-$mean * log(1.0-[my random_number_norm])}
	}

	#>>>
	method random_gauss {} { #<<<
		package require math::special

		math::special::erfc [my random_number_norm]
	}

	#>>>
	method push_state {} { #<<<
		lappend stack [my save_state]
	}

	#>>>
	method pop_state {} { #<<<
		if {[llength $stack] == 0} {
			error "Already at the top of the stack"
		}
		set stack	[lassign $stack state]
		my restore_state $state
	}

	#>>>

	# Random byte source must implement these:
	method random_bytes count { #<<<
		# Return a bytearray of $count random bytes
		error "Not implemented"
	}

	#>>>
	method save_state {} { #<<<
		# Return an opaque value that can be used by restore_state to
		# reconstruct the internal state of the PRNG
		error "Not implemented"
	}

	#>>>
	method restore_state saved_state { #<<<
		# Given $saved_state which was generated by save_state, reconstruct
		# the internal state of the PRNG
		error "Not implemented"
	}

	#>>>
	method subsequence {{name ""}} { #<<<
		# Return a new sequence whose seed is drawn from the current output of
		# this sequence (consuming the output)
		# If $name is supplied, create the sequence object using that name
		error "Not implemented"
	}

	#>>>
}

# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4
