.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "prng" "n" "0.6" "0.6" "Pseudorandom number and sequence utilities"
.hy
.SH NAME
.PP
prng - Pseudorandom number and sequence utilities
.SH SYNOPSIS
.PP
\f[B]package require prng\f[R] ?0.6?
.PP
\f[B]package require prng::blowfish\f[R] ?0.6?
.PP
\f[B]package require prng::mt\f[R] ?0.6?
.PP
\f[B]prng::Sequence create\f[R] \f[I]seqname\f[R] \f[I]seed\f[R]
.PP
\f[B]prng::mt::Sequence create\f[R] \f[I]seqname\f[R] \f[I]seed\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_uint32\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_uint64\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_number_norm\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_number_halfopen\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_number_exponential\f[R] \f[I]max\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_int\f[R] \f[I]inc_bot\f[R]
\f[I]inc_top\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_sort\f[R] \f[I]list\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_pick\f[R] \f[I]list\f[R] ?\f[I]count\f[R]?
.PP
\f[I]seqname\f[R] \f[B]random_normal\f[R] \f[I]mean\f[R]
\f[I]stddev\f[R] ?\f[I]number\f[R]?
.PP
\f[I]seqname\f[R] \f[B]random_exponential\f[R] \f[I]mean\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_gauss\f[R]
.PP
\f[I]seqname\f[R] \f[B]push_state\f[R]
.PP
\f[I]seqname\f[R] \f[B]pop_state\f[R]
.PP
\f[I]seqname\f[R] \f[B]random_bytes\f[R] \f[I]count\f[R]
.PP
\f[I]seqname\f[R] \f[B]save_state\f[R]
.PP
\f[I]seqname\f[R] \f[B]restore_state\f[R] \f[I]saved_state\f[R]
.PP
\f[I]seqname\f[R] \f[B]subsequence\f[R] ?\f[I]name\f[R]?
.SH DESCRIPTION
.PP
This module implements the abstract concept of a sequence of random
numbers (deterministic for a given seed) that can form a hierarchical
tree of sequences of arbitrary complexity.
Each sequence provides utility functions for common random number
requirements: fitting common distributions, uniform distribution across
a precise range, random sorts and other common but subtle requirements,
as well as being able to save and restore the internal state to a point
in time.
Two implementations are provided, one based on a blowfish CSPRNG (which
will provide cryptographic quality pseudorandom numbers at the cost of
higher computation requirements), and the other based on a mersenne
twister RNG: MT19937 (which has a lower computation cost and good
statistical randomness but is not suitable for cryptographic purposes).
.SH COMMANDS
.TP
\f[B]prng::Sequence create\f[R] \f[I]seqname\f[R] \f[I]seed\f[R]
Create a new sequence accessible through the command \f[I]seqname\f[R]
using the blowfish CSPRNG, seeded with the value \f[I]seed\f[R], which
is an arbitrary string of bytes.
.TP
\f[B]prng::mt::Sequence create\f[R] \f[I]seqname\f[R] \f[I]seed\f[R]
Create a new sequence accessible through the command \f[I]seqname\f[R]
using the mersenne twister RNG, seeded with the value \f[I]seed\f[R],
which is an arbitrary string of bytes (but which is ideally a multiple
of 4 bytes in length).
The quality of the generated random numbers is low if the seed has many
zeros.
.TP
\f[I]seqname\f[R] \f[B]random_uint32\f[R]
Return a random unsigned 32bit integer with uniform distribution in the
interval [0, 2\[S3]\[S2]).
.TP
\f[I]seqname\f[R] \f[B]random_uint64\f[R]
Return a random unsigned 64bit integer with uniform distribution in the
interval [0, 2\[u2076]\[u2074]).
.TP
\f[I]seqname\f[R] \f[B]random_number_norm\f[R]
Return a floating point number with uniform distribution in the interval
[0, 1] with 53 bits of precision.
.TP
\f[I]seqname\f[R] \f[B]random_number_halfopen\f[R]
Return a floating point number with uniform distribution in the interval
[0, 1) with 53 bits of precision.
.TP
\f[I]seqname\f[R] \f[B]random_number_exponential\f[R] \f[I]max\f[R]
TBD
.TP
\f[I]seqname\f[R] \f[B]random_int\f[R] \f[I]inc_bot\f[R] \f[I]inc_top\f[R]
Return a random integer with nearly uniform distribution in the interval
[\f[I]inc_bot\f[R], \f[I]inc_top\f[R]].
.TP
\f[I]seqname\f[R] \f[B]random_sort\f[R] \f[I]list\f[R]
Return \f[I]list\f[R] sorted randomly.
.TP
\f[I]seqname\f[R] \f[B]random_pick\f[R] \f[I]list\f[R] ?\f[I]count\f[R]?
Return \f[I]count\f[R] unique elements from \f[I]list\f[R], selected
randomly.
\f[I]list\f[R] must contain at least \f[I]count\f[R] elements.
If \f[I]count\f[R] isn\[cq]t specified it defaults to 1.
.TP
\f[I]seqname\f[R] \f[B]random_normal\f[R] \f[I]mean\f[R] \f[I]stddev\f[R]
Return a random floating-point number with normal distribution with the
mean \f[I]mean\f[R] and standard deviation \f[I]stddev\f[R].
.TP
\f[I]seqname\f[R] \f[B]random_exponential\f[R] \f[I]mean\f[R]
TBD
.TP
\f[I]seqname\f[R] \f[B]random_gauss\f[R]
TBD
.TP
\f[I]seqname\f[R] \f[B]push_state\f[R]
Save the current sequence state to a stack.
.TP
\f[I]seqname\f[R] \f[B]pop_state\f[R]
Restore the most recently saved sequence state from the stack.
.TP
\f[I]seqname\f[R] \f[B]random_bytes\f[R] \f[I]count\f[R]
Return \f[I]count\f[R] random bytes.
.TP
\f[I]seqname\f[R] \f[B]save_state\f[R]
Return a value that fully captures the internal state of the sequence,
suitable for passing to \f[B]restore_state\f[R].
.TP
\f[I]seqname\f[R] \f[B]restore_state\f[R] \f[I]saved_state\f[R]
Restore the sequence internal state to what it was when
\f[I]saved_state\f[R] was generated by \f[B]save_state\f[R].
.TP
\f[I]seqname\f[R] \f[B]subsequence\f[R] ?\f[I]name\f[R]?
Branch a new sequence off of this one.
The resulting sequence will be of the same type as the parent, with an
initial state seeded from the parent.
If \f[I]name\f[R] is supplied, it is the name of the command to access
the new subsequence, otherwise a random name will be generated and
returned.
.SH EXAMPLES
.PP
Generate some random numbers from a sequence seeded with the value
\[lq]hello, sequence\[rq], and others from a subsequence branched off
that one.
.IP
.nf
\f[C]
package require prng
package require prng::mt

prng::mt::Sequence create s1 \[dq]hello, sequence\[dq]
puts \[dq]s1 random_uint32: [s1 random_uint32]\[dq]
puts \[dq]s1 random_uint64: [s1 random_uint64]\[dq]
puts \[dq]s1 random_normal: [s1 random_normal 10 2]\[dq]
s1 subsequence s2
puts \[dq]s2 random_uint32: [s2 random_uint32]\[dq]
puts \[dq]s2 random_uint64: [s2 random_uint64]\[dq]
puts \[dq]s2 random_normal: [s2 random_normal 10 2]\[dq]
\f[R]
.fi
.PP
produces the output:
.IP
.nf
\f[C]
s1 random_uint32: 40479833
s1 random_uint64: 2179017276762469631
s1 random_normal: 10.488755572266877
s2 random_uint32: 2415070459
s2 random_uint64: 16788392099454078255
s2 random_normal: 12.399809108073061
\f[R]
.fi
.SH LICENSE
.PP
This package Copyright 2013-2022 Cyan Ogilvie, and is made available
under the same license terms as the Tcl Core.
.SH AUTHORS
Cyan Ogilvie.
